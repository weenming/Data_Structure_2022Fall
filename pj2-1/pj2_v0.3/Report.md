# A File permission system
## 问题分析
很显然，文档中的
>如果⽤户的⽗节点有对某⽂件的操作权限，那么⽤户有对该⽂件的操作权限有效；
>如果⽤户的⽗节点没有对某⽂件的操作权限，那么⽤户有对该⽂件的操作权限⽆效；
>如果⽤户有对某⽂件的⽗⽂件的操作权限，那么⽤户有对该⽂件的操作权限有效；
>如果⽤户没有对某⽂件的⽗⽂件的操作权限，那么⽤户有对该⽂件的操作权限⽆效；
>如果⽆法根据⽤户_⽂件权限列表查询到结果，那么默认⽤户对该⽂件操作权限⽆效
不能被解释为左半句是右半句的充分条件，否则这个例子：`A用户是B用户的父母结点，x文件是y文件的父母结点。假设B用户对y文件有操作权限，且A用户对x文件有操作权限`就会导致矛盾（第1行和第3行），即使中文的意思似乎应该这样解释。

所以我们根据`过程示例`来推断题目的意图。从`过程示例`中可以发现，用户`A`对文件`x`拥有访问权限`i`的充分必要条件是：`A`和`A`的任意一个祖先*都*拥有对`x`和`x`的任意祖先的访问权限`i`。所以我们只需在2层循环内遍历`A`和`x`的祖先，取访问权限的最小值即可。

## 数据结构
### User Tree
User Tree中用数组储存节点信息：父母结点的`ID`和名字;数组下标即为该节点的`ID`。此外由于Permission信息中按照名字索引用户和文件，我使用一个hash表，key为`name`，val为`ID`来从名字查找到`ID`。

为了构建用户树，我们递归地寻找`USER_root`下的子文件夹并将新结点加入`UserTree`中。

在用户树类中，我们还定义了`GetPermission`方法，通过传入`FileTree`实例，`usr_id`和`file_id`，遍历`usr`和`file`的所有祖先，得到最小的访问权限并返回。当然，若遍历过程中发现了最小可能的访问权限(即`0`)，那么可以即刻跳出循环来改进性能。

### File Tree
文件树的实现和用户树相同，唯一区别为文件树没有`GetPermission`方法。

### Permission
为了读和访问`user_permission_file`，我们定义了`Permission`类，内部数据结构为两层嵌套的Hash表。第一层的`key`是`usr_id`；第二层的`key`是`file_id`。因此，通过两次Hash查找，就能知道某一用户-文件对是否存在权限信息。

## 复杂度分析
### 载入数据
时间复杂度是`O(N_{usr}+N_{file}+N_{pms})`
空间复杂度和树的形状有关，在$O(1)$和$O(N_{usr}+N_{file})$不等。
##### 时间复杂度
- 对于文件树和用户树，递归遍历$O(N)$，其中N是树的节点总数。在树中新增每个结点$O(1)$，总时间复杂度为$O(N_{usr}+N_{file})$
- 对于权限信息文件，遍历用时$O(N_{pms})$
##### 空间复杂度
- 文件树和用户树，最佳情况下递归调用栈深度$O(1)$（只有一层）；最坏情况下$O(N)$
- 权限信息文件，被填充了的项大约是$O(N_{pms})$，但也和Hash表的实现有关

### 获取Permission
##### 时间复杂度
对于某个在树中的深度为`d_{usr}`的用户和深度为$d_{file}$的文件，在最坏情况下需要遍历$d_{usr}d_{file}$次，从`Permission`中搜索同样次数的permission level。最好情况下就是第一次就是`0`权限直接退出。

每次搜索permission level，由于和Hash表有关，最好情况下就是$O(1)$，最坏情况下是$O(N_{pms})$。

##### 空间复杂度
Hash表，被填充的项大约是$O(N_{pms})$。由于遍历所有祖先用非递归实现，空间复杂度是$O(1)$

### 总和
由于用户、文件树的形态以及permission_file中信息的分布未知，树和Hash表的空间、时间复杂度事实上难以估计。如果认为Hash表查找的时间复杂度$O(1)$；用户树和文件树的按照结点被查找次数平均
的深度为$\bar{d}_{usr}$与$\bar{d}_{file}$，且遍历中途break的情况较少，那么总*时间*复杂度可以被估计为：
读取数据$O(N_{usr}+N_{file}+N_{pms})$，一次查询权限$O(\bar{d}_{usr}\bar{d}_{file})$

## 实验环境
- 操作系统：Windows
- 编译器：g++ 12.2.0, MSYS2 build